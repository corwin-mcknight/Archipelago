#pragma once

#include <stddef.h>
#include <stdint.h>

#include <ktl/algorithm>
#include <ktl/maybe>
#include <ktl/utility>

namespace ktl {

template <typename T, size_t N>
class circular_buffer {
   public:
    void push(T value) {
        buffer[tail] = value;
        tail = (tail + 1) % N;
        if (!full()) {
            count++;
        } else {
            head = (head + 1) % N;
        }
    }

    void emplace(T&& value) {
        buffer[tail] = ktl::move(value);
        tail = (tail + 1) % N;
        if (count < N) {
            count++;
        } else {
            head = (head + 1) % N;
        }
    }

    maybe<T> pop() {
        if (empty()) { return ktl::nothing; }

        T value = buffer[head];
        head = (head + 1) % N;
        count--;
        return value;
    }

    maybe<T> peek() {
        if (empty()) { return ktl::nothing; }
        return buffer[head];
    }

    // Copy last N elements into the given buffer.
    size_t copy_last(T* buf, size_t n) {
        if (n == 0 || count == 0) { return 0; }

        size_t available = ktl::min(count, N);
        size_t to_copy = ktl::clamp(n, (size_t)1, available);

        size_t start = (head + available - to_copy) % N;
        for (size_t i = 0; i < to_copy; ++i) { buf[i] = buffer[(start + i) % N]; }

        return to_copy;
    }

    size_t size() const { return count; }
    size_t capacity() const { return N; }
    bool empty() const { return count == 0; }
    bool full() const { return count >= N; }
    float load_factor() const { return static_cast<float>(count) / static_cast<float>(N); }

    template <typename F>
    void for_each(F callback) {
        for (size_t i = 0; i < count; i++) { callback(buffer[(head + i) % N]); }
    }

   private:
    size_t count = 0;
    unsigned int head = 0;
    unsigned int tail = 0;
    T buffer[N];
};

}  // namespace ktl
